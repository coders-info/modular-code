# [Modular Code by Hypermodularity](https://www.coders.info/)

From #clean ideas to code #smells ... Let's talk about The Pragmatic Development based on [HyperModularity](https://wiki.opensourceecology.org/wiki/Hypermodularity)

## Code Expectations

### everyone expect:
  + [clean code](https://en.wikipedia.org/wiki/SOLID)
  + [patterns](https://en.wikipedia.org/wiki/Software_design_pattern)
  + [KISS](https://en.wikipedia.org/wiki/KISS_principle)
  + ...
    
![KISS](https://github.com/tom-sapletta-com/clean-code/assets/5669657/96c736d2-a189-4894-9a1a-cfdf79232bfd)

  
### no one expects the spanish inquisition
  

![no one expects the spanish inquisition](https://github.com/tom-sapletta-com/modular-code/assets/5669657/af423bc7-8112-4d35-8145-882f85299750)



## Code Reality

+ [Legacy Code](https://en.wikipedia.org/wiki/Legacy_system)
+ [Spaghetti Code](https://en.wikipedia.org/wiki/Spaghetti_code)
+ [Code Smell](https://en.wikipedia.org/wiki/Code_smell)
+ ...



## The Pragmatic Development

development = production of **code** to implement **services** based on **requirements**


## Modular code of network

In modular code of network, modular principles help by encouraging the development of concise, focused, and reusable modules that interact with well-defined interfaces, making the overall system robust and adaptable to changes.
Using these principles, developers are encouraged to pay attention to the bigger picture, strive to maintain consistency in code structure, and promote maintainability and scalability.
The concept of hypermodularity has been taken to the next level, where modularity is extremely pronounced, allowing for even greater flexibility, customization, interchangeability and scalability.


![Modular code of network](https://github.com/coders-info/www/assets/5669657/ccee5072-87d6-413c-ba33-37d4777d8a8f)



## Modular principles

It emphasizes the key attributes of modules in a modular code network, including being concise, focused, reusable, and having well-defined interfaces that enhance robustness and adaptability.

### Environment
+ **management** over production
+ **requirements** over expectations

### Source-code
+ **reusability** over code development
+ **writing** over refactoring code

### Data
+ data **standardization** first
+ **fat-data** over fat-function



## Expected Outcomes

By following the modular design principles, developers should aim for the larger framework by ensuring the code structure remains consistent and the product becomes maintainable and scalable.




## Hypermodularity

![hypermodularity](https://github.com/tom-sapletta-com/modular-code/assets/5669657/87475ed6-5a5e-432a-a6e2-8174952f14d7)


### Why use this?

Hypermodularity refers to an advanced or extreme degree of modularity in the design and organization of systems, products, technologies, or processes. Modularity itself is a design principle of creating complex systems from smaller, easily managed, interchangeable and often standardized parts or modules. 
Hypermodularity offers more of flexibility, customization, interchangeability, and scalability.
The feature of modularization is that the more modules there are, the more combinations we have at our disposal. The increase in the number of modules forces their specialization.


### How to use?

Hypermodularity is not about writing, but about reusing code in a network of dependencies

Hypermodularity shifts the burden of programming:
+ from development to management
+ from programming to defining services based on available source-code and data

The smallest element of a modular network is one running service that can be written or reused thanks to successive modular building blocks of reusable code.

This is the hyper modular network of code ...



## Why and How?

Modular programming is a software design approach that focuses on breaking down programs into independent, interchangeable modules where each contains everything necessary to execute a specific functionality. This separation simplifies complex systems, makes the code easier to manage, and promotes code reuse. 

Here’s how each of the mentioned principle fits into modular programming:

### 1. Management over Production
   - **Why to Use:** The emphasis on management rather than production ensures that codebases are well-organized and easy to navigate, making the development process more efficient and faster.
   - **How to Use:** Use a clear modular structure in which each module has one responsibility. Organize code repositories and document each module's functionality and interfaces. This helps not only with current production, but also with future management and scaling of the code base.

### 2. Requirements over Expectations
   - **Why to Use:** Prioritizing requirements ensures that the modules developed will meet the actual needs of the users or system, instead of being based on developers' assumptions or expectations that may not align.
   - **How to Use:** Start with a comprehensive requirements analysis and use it to define the scope and design of each module. Make sure you create test cases based on requirements rather than expectations to verify that the module works as expected.

### 3. Reusability over Code Development
   - **Why to Use:** Focusing on reusability can significantly reduce development time and effort, as well as reduce the risk of errors because well-tested modules can be reused rather than rebuilt.
   - **How to Use:** Design modules with generality and loose coupling in mind. Create tool libraries, follow standard interfaces, and use design patterns for easy reuse. Make sure that the module does not depend heavily on a specific context or other modules.

### 4. Writing over Refactoring Code
   - **Why to Use:** Writing code correctly from the start reduces the need for extensive refactoring later, which can be resource-intensive and risky if it leads to unforeseen problems.
   - **How to Use:** Spend more time in the design and planning phase to thoroughly understand the requirements. Write simple, clean and understandable code and include reviews and pair programming to detect potential problems early.

### 5. Data Standardization First
   - **Why to Use:** Standardization simplifies data exchange between modules and systems, promotes interoperability, and reduces complexity when scaling or integrating with other systems.
   - **How to Use:** Define clear protocols, data formats and interfaces from the beginning. When possible, stick to well-accepted industry standards and ensure that all modules comply with specific data standards.

### 6. Fat-Data over Fat-Function
   - **Why to Use:** This principle encourages the creation of data structures with rich information content, reducing and moving the logical functions to interfaces and middleware
   - **How to Use:** Design your data models to be comprehensive and include all necessary information. This approach often favors object-oriented designs, where data and related behaviors are combined into objects. Divide objects into data models that do not contain method functions and those that contain them but do not have attributes, i.e. data. Separation of data from functions facilitates expansion and does not create artificial dependencies. For OOP - [Object-oriented programming](https://en.wikipedia.org/wiki/Object-oriented_programming), [Single-responsibility principle](https://en.wikipedia.org/wiki/Single-responsibility_principle) and [Dependency injection](https://en.wikipedia.org/wiki/Dependency_injection) will be helpful



## Contexts

### Technology and Computing
In software development, a hypermodular architecture would allow for easier updates, maintenance, and scale, as individual modules or components can be modified or replaced without impacting the entire system.

### Manufacturing and Industry
Hypermodular design in manufacturing processes or equipment can enable factories to quickly adapt to new product lines or changes in demand by reconfiguring modular components.

### Urban Design and Architecture
Hypermodularity in urban design might involve the creation of living spaces or structures that can be quickly assembled, disassembled, and reassembled in different configurations depending on the changing needs of the inhabitants.

### Organizational Structures
In management, a hypermodular organizational structure would reflect a highly flexible and adaptable model where teams or units can be formed, reformed, and disbanded as needed to respond to various projects and challenges.



## Hypermodularity in Science

Hypermodularity refers to an extreme degree of modularity, characterized by highly interconnected but independent units or modules. 
This concept can be applied to various fields, ranging from natural systems to technology and science. 
Let's explore how hypermodularity manifests across these different areas:

1. **Nature:**
   - In ecology, hypermodularity can be seen in ecosystems, where a diverse range of species and habitats interact but also function independently. Food webs are an example, where each species may play a distinct role, but the removal or addition of one species can have ripple effects through the system.
   - In biology, the concept of hypermodularity can be seen in the organization of cells and organs within an organism. Cells are self-contained units that can independently perform specific functions yet are part of larger biological systems.

2. **Technology:**
   - In software engineering, hypermodularity is the backbone of microservices architecture, where applications are structured as collections of loosely coupled services that can be developed, deployed, and scaled independently.
   - In hardware, we see hypermodularity in computer design, such as the standardized interfaces allowing components like RAM, hard drives, and processors to be swapped and upgraded with ease.

3. **Medicine:**
   - In medical treatment, hypermodularity can apply to personalized medicine, where treatments are tailored to individual patients. Different modules (e.g., medications, physical therapies, and surgical interventions) can be combined to address a patient's specific health concerns.
   - Prosthetics and implants are physically modular, designed to integrate with the human body. They can be mixed and matched to meet the specific needs of different patients.

4. **Chemistry:**
   - Hypermodularity is inherent in supramolecular chemistry, where molecules form complex structures through non-covalent bonds. These structures can be thought of as modules that assemble into larger systems.
   - Polymer chemistry also uses a modular approach, with monomers serving as building blocks that can be assembled into various polymers with different properties and applications.

5. **Physics:**
   - In condensed matter physics, the concept of modularity is seen in crystallography, where the repeating unit cell acts as the basic module for the entire crystal structure.
   - In particle physics, the Standard Model is a hypermodular framework where particles and forces are seen as separate modules that interact according to specific principles.

Overall, hypermodularity allows for complexity within a system while maintaining a level of simplicity, adaptability, and robustness in individual components. 
For example, in technology, it facilitates innovation as new modules can be added or updated without overhauling entire systems. 
In nature, it enables resilience, as systems can adapt to changes by reorganizing modular connections. 
In science, it helps to understand complex structures by studying their individual modules. 
Hypermodularity, when implemented thoughtfully, can therefore contribute to efficiency, flexibility, and sustainability across multiple fields.



## Use Cases

from cosmic ideas to management ... 

### HD-SSP Space Solar Power

+ HD-SSP [Hypermodular Distributed Space Solar Power](https://www.esa.int/gsp/ACT/doc/nrg/SPS%202013/EXT-RPR-1309%20Martin%20Leitgeber%20-%20IAC_SSP_Competition_2013_final092213.pdf)

Hypermodularity is an attractive principle for space solar power architecture, as e.g. recently used in Ref. [5].
By assembling full SSP stations from a large amount of identical elements, production cost are significantly de-creased and reliability of the system is increased due to fewer single points of failure



### Modular edge computing

By combining that 3 layers: **hardware**, software with network of **services** and **data**, can be achieved modular edge computing:
+ modular **hardware** [Modular Edge Computing Hardware - Militarity](https://www.militarity.com/)
+ modular **data** storage on one file [Newline Delimited Objects Format - NDOF.org](https://www.ndof.org/)
+ modular network **services** [dynamic infrastructure of services based on DNS  - Dynapsys](http://www.dynapsys.com) based on [DialogWare](http://Dialogware.com) text to software platform


### Automated Software House

+ SaaS to serve Dialogware ecosystem [OneDayRun](OneDay.run)
  + Text To Software generator [DialogWare](http://Dialogware.com)
    + [coDialog.com](http://www.coDialog.com) - Human Interface: voice, text, mind, behaviors
      + format generation [dialogSchema.com](http://www.dialogschema.com) for [dialogStory.com](http://www.dialogStory.com) output
      + [dialogStory.com](http://www.dialogStory.com) exchange file between **DialogWare** and **DialogChain**
    + Code Synchronisation Service, Exchange between **coDialog** and **DialogChain** - [DialogSync](http://www.DialogSync.com)      
    + Versioning System for **DialogSync** file format - [DialogChain](https://www.dialogchain.com/)
    + Continuous Deployment system serving **DialogChain** SourceCode  [DialogStream](https://www.DialogStream.com/)    


### Resource loading standard

+ [webstream.dev](https://www.webstream.dev/#/) is a modular loading standard that enables the implementation of streaming via HTTP for:
  + content
  + media
  + documents
  + application

Streaming application/interface directly on frontend, without building backend side is part of wapka ecosystem to build Application based on PaaS infrastructure as Aplication Platform as a Service or (APaaS) Function as a Service (FaaS)

WebStream is a rapid prototyping, playing and learning environment for web development. 
Extends the JavaScripts language with Stream Thinking and libraries for building asyncron, decentralized, modular applications. Web Stream a continuous improving by a flowing stream;



### Modular Packages

+ [hypermodular-gitmodules/README.md at main · tom-sapletta-com/hypermodular-gitmodules](https://github.com/tom-sapletta-com/hypermodular-gitmodules/blob/main/README.md)
+ [apipackage.com](https://github.com/apipackage)
+ alternative way to handle git-level dependencies, alternative to gitmodules dependencies: [ApiFork](https://github.com/apifork)  
+ creating documentation is not easy in hundreds of projects, where are dependencies we need some simple tool to manage the documentation from the terminal, during programming: [flatedit/bash: bash.flatedit.com](https://github.com/flatedit/bash)


---

+ Author: [Tom Sapletta - Platform & DevOps Engineer & Hardware Developer, Expat in Germany](https://tom.sapletta.com/) 
+ more about [HyperModularity](https://www.hypermodularity.com/) in draft of book
  
---

+ [edit](https://github.com/coders-info/www/edit/main/README.md)
+ [project](https://github.com/coders-info/)
