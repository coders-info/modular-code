# [Modular Code by Hypermodularity](https://www.coders.info/)

From #clean ideas to code #smells ... Let's talk about The Pragmatic Development based on [HyperModularity](https://wiki.opensourceecology.org/wiki/Hypermodularity)

## Code Expectations

### everyone expect:
  + [clean code](https://en.wikipedia.org/wiki/SOLID)
  + [patterns](https://en.wikipedia.org/wiki/Software_design_pattern)
  + [KISS](https://en.wikipedia.org/wiki/KISS_principle)
  + ...
    
![KISS](https://github.com/tom-sapletta-com/clean-code/assets/5669657/96c736d2-a189-4894-9a1a-cfdf79232bfd)

  
### no one expects the spanish inquisition
  

![no one expects the spanish inquisition](https://github.com/tom-sapletta-com/modular-code/assets/5669657/af423bc7-8112-4d35-8145-882f85299750)



## Code Reality

+ [Legacy Code](https://en.wikipedia.org/wiki/Legacy_system)
+ [Spaghetti Code](https://en.wikipedia.org/wiki/Spaghetti_code)
+ [Code Smell](https://en.wikipedia.org/wiki/Code_smell)
+ ...



## The Pragmatic Development

development = production of **code** to implement **services** based on **requirements**


## Modular code of network

In modular code of network, modular principles help by encouraging the development of concise, focused, and reusable modules that interact with well-defined interfaces, making the overall system robust and adaptable to changes.
Using these principles, developers are encouraged to pay attention to the bigger picture, strive to maintain consistency in code structure, and promote maintainability and scalability.
The concept of hypermodularity has been taken to the next level, where modularity is extremely pronounced, allowing for even greater flexibility, customization, interchangeability and scalability.


![Modular code of network](https://github.com/coders-info/www/assets/5669657/ccee5072-87d6-413c-ba33-37d4777d8a8f)



## Modular principles

It emphasizes the key attributes of modules in a modular code network, including being concise, focused, reusable, and having well-defined interfaces that enhance robustness and adaptability.

### Environment
+ **management** over production
+ **requirements** over expectations

### Source-code
+ **reusability** over code development
+ **writing** over refactoring code

### Data
+ data **standardization** first
+ **fat-data** over fat-function



## Expected Outcomes

By following the modular design principles, developers should aim for the larger framework by ensuring the code structure remains consistent and the product becomes maintainable and scalable.




## Hypermodularity

![hypermodularity](https://github.com/tom-sapletta-com/modular-code/assets/5669657/87475ed6-5a5e-432a-a6e2-8174952f14d7)


### Why use this?

Hypermodularity refers to an advanced or extreme degree of modularity in the design and organization of systems, products, technologies, or processes. Modularity itself is a design principle of creating complex systems from smaller, easily managed, interchangeable and often standardized parts or modules. 
Hypermodularity offers more of flexibility, customization, interchangeability, and scalability.
The feature of modularization is that the more modules there are, the more combinations we have at our disposal. The increase in the number of modules forces their specialization.

### How to use?

Hypermodularity is not about writing, but about reusing code in a network of dependencies

Hypermodularity shifts the burden of programming:
+ from development to management
+ from programming to defining services based on available source-code and data

The smallest element of a modular network is one running service that can be written or reused thanks to successive modular building blocks of reusable code.

This is the hyper modular network of code ...



## Why and How?

Modular programming is a software design approach that focuses on breaking down programs into independent, interchangeable modules where each contains everything necessary to execute a specific functionality. This separation simplifies complex systems, makes the code easier to manage, and promotes code reuse. 

Hereâ€™s how each of the mentioned principle fits into modular programming:

### 1. Management over Production
   - **Why to Use:** The emphasis on management rather than production ensures that codebases are well-organized and easy to navigate, making the development process more efficient and faster.
   - **How to Use:** Use a clear modular structure in which each module has one responsibility. Organize code repositories and document each module's functionality and interfaces. This helps not only with current production, but also with future management and scaling of the code base.

### 2. Requirements over Expectations
   - **Why to Use:** Prioritizing requirements ensures that the modules developed will meet the actual needs of the users or system, instead of being based on developers' assumptions or expectations that may not align.
   - **How to Use:** Start with a comprehensive requirements analysis and use it to define the scope and design of each module. Make sure you create test cases based on requirements rather than expectations to verify that the module works as expected.

### 3. Reusability over Code Development
   - **Why to Use:** Focusing on reusability can significantly reduce development time and effort, as well as reduce the risk of errors because well-tested modules can be reused rather than rebuilt.
   - **How to Use:** Design modules with generality and loose coupling in mind. Create tool libraries, follow standard interfaces, and use design patterns for easy reuse. Make sure that the module does not depend heavily on a specific context or other modules.

### 4. Writing over Refactoring Code
   - **Why to Use:** Writing code correctly from the start reduces the need for extensive refactoring later, which can be resource-intensive and risky if it leads to unforeseen problems.
   - **How to Use:** Spend more time in the design and planning phase to thoroughly understand the requirements. Write simple, clean and understandable code and include reviews and pair programming to detect potential problems early.

### 5. Data Standardization First
   - **Why to Use:** Standardization simplifies data exchange between modules and systems, promotes interoperability, and reduces complexity when scaling or integrating with other systems.
   - **How to Use:** Define clear protocols, data formats and interfaces from the beginning. When possible, stick to well-accepted industry standards and ensure that all modules comply with specific data standards.

### 6. Fat-Data over Fat-Function
   - **Why to Use:** This principle encourages the creation of data structures with rich information content, reducing and moving the logical functions to interfaces and middleware
   - **How to Use:** Design your data models to be comprehensive and include all necessary information. This approach often favors object-oriented designs, where data and related behaviors are combined into objects. Divide objects into data models that do not contain method functions and those that contain them but do not have attributes, i.e. data. Separation of data from functions facilitates expansion and does not create artificial dependencies.



## Contexts

+ **Technology and Computing**: In software development, a hypermodular architecture would allow for easier updates, maintenance, and scale, as individual modules or components can be modified or replaced without impacting the entire system.

+ **Manufacturing and Industry**: Hypermodular design in manufacturing processes or equipment can enable factories to quickly adapt to new product lines or changes in demand by reconfiguring modular components.

+ **Urban Design and Architecture**: Hypermodularity in urban design might involve the creation of living spaces or structures that can be quickly assembled, disassembled, and reassembled in different configurations depending on the changing needs of the inhabitants.

+ **Organizational Structures**: In management, a hypermodular organizational structure would reflect a highly flexible and adaptable model where teams or units can be formed, reformed, and disbanded as needed to respond to various projects and challenges.



## Use Cases

### Modular edge computing

By combining that 3 layers: **hardware**, software with network of **services** and **data**, we can achieve scalable edge computing:
+ modular **hardware** [Modular Edge Computing Hardware - Militarity](https://www.militarity.com/)
+ modular **data** storage on one file [Newline Delimited Objects Format - NDOF.org](https://www.ndof.org/)
+ modular network **services** [dynamic infrastructure of services based on DNS  - Dynapsys](http://www.dynapsys.com)



### HD-SSP Space Solar Power

+ HD-SSP [Hypermodular Distributed Space Solar Power](https://www.esa.int/gsp/ACT/doc/nrg/SPS%202013/EXT-RPR-1309%20Martin%20Leitgeber%20-%20IAC_SSP_Competition_2013_final092213.pdf)

Hypermodularity is an attractive principle for space solar power architecture, as e.g. recently used in Ref. [5].
By assembling full SSP stations from a large amount of identical elements, production cost are significantly de-creased and reliability of the system is increased due to fewer single points of failure



---

+ Author: [Tom Sapletta - Platform & DevOps Engineer & Hardware Developer, Expat in Germany](https://tom.sapletta.com/) 
+ more about [HyperModularity](https://www.hypermodularity.com/) in draft of book
---

+ [edit](https://github.com/coders-info/www/edit/main/README.md)
+ [project](https://github.com/coders-info/)
